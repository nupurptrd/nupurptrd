// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Workspace {
  id        String     @id @default(cuid())
  name      String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  books     Book[]
  series    Series[]
  episodes  Episode[]

  @@map("workspaces")
}

model Book {
  id               String   @id @default(cuid())
  title            String
  author           String
  language         String   @default("en")
  genre            String
  contentText      String   @db.Text
  wordCount        Int
  estimatedPages   Int
  workspaceId      String
  workspace        Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  series           Series[]
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([workspaceId])
  @@map("books")
}

model Series {
  id               String     @id @default(cuid())
  bookId           String
  book             Book       @relation(fields: [bookId], references: [id], onDelete: Cascade)
  workspaceId      String
  workspace        Workspace  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  title            String
  description      String?    @db.Text
  episodeCount     Int        @default(0)
  status           SeriesStatus @default(GENERATING)
  episodes         Episode[]
  dramaSkeleton    DramaSkeleton?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@index([bookId])
  @@index([workspaceId])
  @@map("series")
}

model DramaSkeleton {
  id          String   @id @default(cuid())
  seriesId    String   @unique
  series      Series   @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  beats       Beat[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("drama_skeletons")
}

model Beat {
  id               String   @id @default(cuid())
  dramaSkeleton    DramaSkeleton @relation(fields: [dramaSkeleton_id], references: [id], onDelete: Cascade)
  dramaSkeleton_id String
  arcNumber        Int
  beatType         BeatType
  description      String   @db.Text
  narrativeNote    String?  @db.Text
  episodeStart     Int
  episodeEnd       Int

  @@map("beats")
}

model Episode {
  id                    String         @id @default(cuid())
  seriesId              String
  series                Series         @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  workspaceId           String
  workspace             Workspace      @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  episodeNumber         Int
  title                 String
  scriptText            String         @db.Text
  durationTargetSec     Int            @default(75) // 60-90 seconds
  estimatedReadTimeSec  Int
  characterCount        Int
  hasCliffhanger        Boolean        @default(false)
  narratorRatioPct      Int            @default(0)
  dialogueRatioPct      Int            @default(0)
  status                EpisodeStatus  @default(GENERATING)
  validationErrors      String[]       @default([])
  validationWarnings    String[]       @default([])
  scenes                Scene[]
  promptTrace           PromptTrace?
  generationStats       GenerationStats?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  @@unique([seriesId, episodeNumber])
  @@index([seriesId])
  @@index([workspaceId])
  @@map("episodes")
}

model Scene {
  id            String   @id @default(cuid())
  episodeId     String
  episode       Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  sceneNumber   Int
  title         String
  narration      String   @db.Text
  dialogue      String?  @db.Text
  characters    String[]
  sfxNotes      String?
  durationSec   Int
  createdAt     DateTime @default(now())

  @@index([episodeId])
  @@map("scenes")
}

model PromptTrace {
  id                String   @id @default(cuid())
  episodeId         String   @unique
  episode           Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  model             String   // "gpt-4", "claude-3", etc.
  promptTemplate    String   @db.Text
  promptFull        String   @db.Text
  responseText      String?  @db.Text
  estimatedTokens   Int      @default(0)
  costUsd           Float    @default(0.0)
  generationTimeMs  Int
  createdAt         DateTime @default(now())

  @@map("prompt_traces")
}

model GenerationStats {
  id                    String   @id @default(cuid())
  episodeId             String   @unique
  episode               Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  wordCount             Int
  sentenceCount         Int
  uniqueCharacterCount  Int
  narratorWordCount     Int
  dialogueWordCount     Int
  avgWordsPerSentence   Float
  readabilityScore      Float

  @@map("generation_stats")
}

// schema.prisma



model DocumentChunk {
  id         Int                 @id @default(autoincrement())
  content    String
  pageNumber Int                 @map("page_number") // Dimensions for gemini-embedding-001
  embedding  Unsupported("vector(3072)") 

  @@map("document_chunks")
}

enum SeriesStatus {
  GENERATING
  READY
  COMPLETED
  FAILED
}

enum EpisodeStatus {
  GENERATING
  VALIDATION_FAILED
  READY
  ARCHIVED
}

enum BeatType {
  HOOK
  ESCALATION
  TENSION
  REVELATION
  CLIFFHANGER
}
